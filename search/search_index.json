{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Taiphi Demo","text":"<p>The Chinese Language Teaching Material Engine is an innovative system designed to streamline the process of creating high-quality educational content. This sophisticated tool takes input from teachers and transforms it through a series of steps to produce comprehensive and engaging teaching materials for Chinese language learners.</p> <ul> <li>Input Processing: The engine begins by accepting various inputs from teachers, such as lesson objectives, target vocabulary, and grammar points.</li> <li>Content Generation: Utilizing advanced natural language processing and AI algorithms, the system generates draft content, including exercises, dialogues, and cultural notes.</li> <li>Agentic AI Enhancement: As a key highlight, the engine employs Agentic AI to intelligently refine and optimize the generated content, ensuring it meets pedagogical standards and adapts to learner needs.</li> </ul>"},{"location":"#workflow","title":"Workflow","text":"<pre><code>graph LR\n  A[Start] --&gt; G[State&lt;br&gt;Machine]\n  G --&gt; B[Query&lt;br&gt;Extract]\n  G --&gt; |state| C\n  G --&gt; |state| D\n  G --&gt; |state| E\n  B --&gt;|Edge 1| C[Call Taiphi&lt;br&gt;Model]\n  C --&gt; |Edge 2|D[Generate Summary&lt;br&gt;and Instructions]\n  D ----&gt;|Edge 3| E[Output to&lt;br&gt;Copilot agent]\n  E --&gt; F[End]\n\n  style G fill:#000080,color:#ffffff</code></pre>"},{"location":"#langgraph-documentation","title":"LangGraph Documentation","text":"<p>For full documentation visit   LangGraph Documentation.</p>"},{"location":"calltaiphi/","title":"CallTaiphi","text":""},{"location":"calltaiphi/#calltaiphi","title":"CallTaiphi","text":"<p>The <code>CallTaiphi</code> class is a key component of the Taiphi library, responsible for managing API calls to language models and handling various aspects of the conversation flow. Here's an overview of its main features and functionalities:</p> <ol> <li> <p>Initialization: The class is initialized with configuration parameters, including the model to use, temperature, and other settings.</p> </li> <li> <p>Conversation Management: It maintains a conversation history, allowing for context-aware interactions with the language model.</p> </li> <li> <p>API Interaction: The class handles API calls to the specified language model, supporting different providers like OpenAI and Anthropic.</p> </li> <li> <p>Prompt Handling: It processes user inputs and system prompts, combining them with the conversation history to generate appropriate queries for the language model.</p> </li> <li> <p>Response Processing: The class manages the responses from the language model, including parsing, formatting, and updating the conversation history.</p> </li> <li> <p>Error Handling: It includes mechanisms to handle various errors that may occur during API calls or processing.</p> </li> <li> <p>Customization: The class allows for customization of various parameters, such as the number of tokens to consider from the conversation history.</p> </li> <li> <p>Utility Functions: It provides utility methods for tasks like counting tokens, truncating conversations, and formatting prompts.</p> </li> </ol> <p>The <code>CallTaiphi</code> class serves as a central component for interacting with language models in the Taiphi library, abstracting away much of the complexity involved in managing conversations and API interactions.</p> <code>taiphi.calltaiphi</code>"},{"location":"calltaiphi/#taiphi.calltaiphi.CallTaiphi","title":"<code>CallTaiphi(state)</code>","text":"<p>Call the Taiphi service and update the agent state with the results.</p> <p>This function is responsible for interacting with the Taiphi service, which is presumably an external AI or data processing system. It takes the current state of the agent, sends a request to Taiphi, and updates the state with the response.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AgentState</code> <p>The current state of the agent. This object contains all the necessary information about the ongoing conversation and processing steps.</p> required <p>Returns:</p> Name Type Description <code>AgentState</code> <code>AgentState</code> <p>The updated state after calling Taiphi. This includes: - A new message indicating that CallTaiphi was executed. - A placeholder message for adding user query information.</p> Note <p>This function currently adds placeholder messages to the state. In a full implementation, it would likely: 1. Extract relevant information from the state to form a query. 2. Send this query to the Taiphi service. 3. Process the response from Taiphi. 4. Update the state with the processed information.</p> TODO <ul> <li>Implement actual connection to Taiphi service.</li> <li>Add error handling for network issues or service unavailability.</li> <li>Include more detailed state updates based on Taiphi's response.</li> </ul> Source code in <code>taiphi/calltaiphi.py</code> <pre><code>def CallTaiphi(state: AgentState) -&gt; AgentState:\n    \"\"\"\n    Call the Taiphi service and update the agent state with the results.\n\n    This function is responsible for interacting with the Taiphi service,\n    which is presumably an external AI or data processing system. It takes\n    the current state of the agent, sends a request to Taiphi, and updates\n    the state with the response.\n\n    Args:\n        state (AgentState): The current state of the agent. This object\n            contains all the necessary information about the ongoing\n            conversation and processing steps.\n\n    Returns:\n        AgentState: The updated state after calling Taiphi. This includes:\n            - A new message indicating that CallTaiphi was executed.\n            - A placeholder message for adding user query information.\n\n    Note:\n        This function currently adds placeholder messages to the state.\n        In a full implementation, it would likely:\n        1. Extract relevant information from the state to form a query.\n        2. Send this query to the Taiphi service.\n        3. Process the response from Taiphi.\n        4. Update the state with the processed information.\n\n    TODO:\n        - Implement actual connection to Taiphi service.\n        - Add error handling for network issues or service unavailability.\n        - Include more detailed state updates based on Taiphi's response.\n    \"\"\"\n    state[\"messages\"].append(CallTaiphi.__name__)\n    state[\"messages\"].append(\"add user+query\")\n    return state\n</code></pre>"},{"location":"generateinstruct/","title":"GenerateInstruct","text":""},{"location":"generateinstruct/#overview","title":"Overview","text":"<p>GenerateInstruct is a module/class that [brief description of its purpose and functionality].</p>"},{"location":"generateinstruct/#api-reference","title":"API Reference","text":"<code>taiphi.generateinstruct</code>"},{"location":"generateinstruct/#taiphi.generateinstruct.GenerateInstruct","title":"<code>GenerateInstruct(state)</code>","text":"<p>Generate instructions based on the current state.</p> <p>This function adds two messages to the state's message list: 1. The name of the function itself 2. A placeholder message indicating that a user query should be added</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AgentState</code> <p>The current state of the agent, containing information                 such as messages and other relevant data.</p> required <p>Returns:</p> Name Type Description <code>AgentState</code> <code>AgentState</code> <p>The updated state with new messages appended to the message list.</p> Note <p>This function is a placeholder and should be expanded to include actual instruction generation logic based on the user's query and the current state.</p> Source code in <code>taiphi/generateinstruct.py</code> <pre><code>def GenerateInstruct(state: AgentState) -&gt; AgentState:\n    \"\"\"\n    Generate instructions based on the current state.\n\n    This function adds two messages to the state's message list:\n    1. The name of the function itself\n    2. A placeholder message indicating that a user query should be added\n\n    Args:\n        state (AgentState): The current state of the agent, containing information\n                            such as messages and other relevant data.\n\n    Returns:\n        AgentState: The updated state with new messages appended to the message list.\n\n    Note:\n        This function is a placeholder and should be expanded to include actual\n        instruction generation logic based on the user's query and the current state.\n    \"\"\"\n    state[\"messages\"].append(GenerateInstruct.__name__)\n    state[\"messages\"].append(\"add user+query\")\n    return state\n</code></pre>"},{"location":"generateinstruct/#usage-examples","title":"Usage Examples","text":"<p>Here are some common usage examples for GenerateInstruct:</p>"},{"location":"main/","title":"Main","text":""},{"location":"main/#main-app-to-execute","title":"Main app to execute","text":"<p>The <code>main.py</code> file serves as the entry point for the Taiphi application. This module contains the primary execution logic and orchestrates the overall flow of the program. Here's an overview of its key components and functionality:</p> <ol> <li> <p>Imports: The file likely imports necessary modules and dependencies required for the application.</p> </li> <li> <p>Configuration: It may include setup for any configuration parameters or environment variables.</p> </li> <li> <p>Main function: There's probably a <code>main()</code> function or a similar entry point that initializes the application and controls the execution flow.</p> </li> <li> <p>Application logic: The file implements the core application logic, potentially including:</p> </li> <li>Data processing</li> <li>User interface initialization (if applicable)</li> <li> <p>Integration with other modules or services</p> </li> <li> <p>Error handling: It likely includes error handling and logging mechanisms to manage exceptions and provide debugging information.</p> </li> <li> <p>Execution: The file ends with a conditional statement to run the main function when the script is executed directly.</p> </li> </ol> <p>For more detailed information about the implementation, please refer to the source code in <code>taiphi/main.py</code>.</p> <code>taiphi.main</code> <p>This module defines the main structure and flow of the Taiphi agent system.</p> <p>It sets up a state graph using langgraph, defining the nodes and edges for the agent's workflow. The graph includes steps for query extraction, calling Taiphi, and generating instructions.</p>"},{"location":"queryextract/","title":"QueryExtract","text":""},{"location":"queryextract/#queryextractnode","title":"QueryExtractNode","text":"<p>The <code>QueryExtractNode</code> is a crucial component in the taiphi library, designed to extract structured information from unstructured text using large language models (LLMs). This node is particularly useful for converting free-form text into a structured format based on a predefined schema.</p>"},{"location":"queryextract/#overview","title":"Overview","text":"<p>The <code>QueryExtractNode</code> operates by:</p> <ol> <li>Taking an input text and a schema as inputs.</li> <li>Utilizing an LLM to analyze the text and extract relevant information.</li> <li>Structuring the extracted information according to the provided schema.</li> <li>Returning the structured data in a format that adheres to the schema.</li> </ol> <p>This node is especially valuable in scenarios where you need to: - Extract specific data points from lengthy documents or conversations. - Convert unstructured user inputs into structured data for further processing. - Automate the parsing of complex text into predefined data structures.</p>"},{"location":"queryextract/#key-features","title":"Key Features","text":"<ul> <li>Flexible schema definition: Allows users to define custom schemas for data extraction.</li> <li>LLM-powered extraction: Leverages the power of large language models for intelligent text analysis.</li> <li>Structured output: Ensures that the extracted data is returned in a consistent, structured format.</li> <li>Customizable prompts: Enables fine-tuning of the extraction process through customizable LLM prompts.</li> </ul>"},{"location":"queryextract/#usage","title":"Usage","text":"<p>The <code>QueryExtractNode</code> can be integrated into various data processing pipelines, particularly those dealing with natural language inputs. It serves as a bridge between unstructured text and structured data, making it an essential tool for tasks such as:</p> <ul> <li>Information retrieval from documents</li> <li>Automated form</li> </ul> <code>taiphi.queryextract</code>"},{"location":"queryextract/#taiphi.queryextract.QueryExtract","title":"<code>QueryExtract(state)</code>","text":"<p>Extract and process query information from the given agent state.</p> <p>This function is responsible for extracting query-related information from the input state and adding it to the state's message list. It appends the function name and a placeholder message for adding user and query information.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>AgentState</code> <p>The current state of the agent, containing information                 about the ongoing conversation and processing.</p> required <p>Returns:</p> Name Type Description <code>AgentState</code> <code>AgentState</code> <p>The updated state with additional messages appended.</p> Note <ul> <li>This function currently adds placeholder messages and should be   expanded to actually extract and add user and query information.</li> <li>The exact format and content of the \"add user+query\" message should   be defined based on the specific requirements of the system.</li> </ul> Example <p>initial_state = AgentState(messages=[]) updated_state = QueryExtract(initial_state)</p> Source code in <code>taiphi/queryextract.py</code> <pre><code>def QueryExtract(state: AgentState) -&gt; AgentState:\n    \"\"\"\n    Extract and process query information from the given agent state.\n\n    This function is responsible for extracting query-related information from\n    the input state and adding it to the state's message list. It appends the\n    function name and a placeholder message for adding user and query information.\n\n    Args:\n        state (AgentState): The current state of the agent, containing information\n                            about the ongoing conversation and processing.\n\n    Returns:\n        AgentState: The updated state with additional messages appended.\n\n    Note:\n        - This function currently adds placeholder messages and should be\n          expanded to actually extract and add user and query information.\n        - The exact format and content of the \"add user+query\" message should\n          be defined based on the specific requirements of the system.\n\n    Example:\n        initial_state = AgentState(messages=[])\n        updated_state = QueryExtract(initial_state)\n        # updated_state.messages will now contain:\n        # [\"QueryExtract\", \"add user+query\"]\n    \"\"\"\n    state[\"messages\"].append(QueryExtract.__name__)\n    state[\"messages\"].append(\"add user+query\")\n    return state\n</code></pre>"},{"location":"queryextract/#taiphi.queryextract.QueryExtract--updated_statemessages-will-now-contain","title":"updated_state.messages will now contain:","text":""},{"location":"queryextract/#taiphi.queryextract.QueryExtract--queryextract-add-userquery","title":"[\"QueryExtract\", \"add user+query\"]","text":""},{"location":"statemachine/","title":"StateMachine","text":""},{"location":"statemachine/#statemachine","title":"StateMachine","text":"<p>The StateMachine class in LangGraph is a fundamental component for managing the flow and state of conversational AI systems. It provides a structured way to define, transition between, and manage different states in a conversation or task execution process.</p>"},{"location":"statemachine/#overview-of-statemachine-in-langgraph","title":"Overview of StateMachine in LangGraph","text":"<ol> <li> <p>Purpose: The StateMachine helps in organizing complex conversational flows or task execution processes into manageable states.</p> </li> <li> <p>State Management: It keeps track of the current state and allows for transitions between states based on defined rules or conditions.</p> </li> <li> <p>Flexibility: Supports both deterministic and non-deterministic state transitions, making it suitable for various AI applications.</p> </li> <li> <p>Integration: Works seamlessly with other LangGraph components, such as agents and tools.</p> </li> </ol>"},{"location":"statemachine/#key-concepts","title":"Key Concepts","text":"<ol> <li> <p>States: Represent different stages or conditions in a conversation or process.</p> </li> <li> <p>Transitions: Define the rules for moving from one state to another.</p> </li> <li> <p>Actions: Functions or operations that are executed when entering, exiting, or during a state.</p> </li> <li> <p>Events: Triggers that can cause state transitions.</p> </li> </ol>"},{"location":"statemachine/#usage-in-langgraph","title":"Usage in LangGraph","text":"<p>The StateMachine is typically used to:</p> <ul> <li>Define the overall structure of a conversational flow</li> <li>Manage complex decision-making processes</li> <li>Implement multi-step tasks or workflows</li> <li>Handle error states and recovery mechanisms</li> </ul>"},{"location":"statemachine/#benefits","title":"Benefits","text":"<ul> <li>Improves code organization and readability</li> <li>Enhances maintainability of complex AI systems</li> <li>Facilitates easier debugging and testing of conversational flows</li> <li>Allows for modular design of AI applications</li> </ul> <p>By leveraging the StateMachine class, developers can create more robust and structured AI systems that can handle complex interactions and tasks efficiently.</p> <code>taiphi.statemachine</code>"},{"location":"statemachine/#taiphi.statemachine.AgentState","title":"<code>AgentState</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Represents the state of the agent throughout its execution.</p> <p>This TypedDict defines the structure of the agent's state, including various fields that are updated and accessed during the agent's operation.</p> <p>Attributes:</p> Name Type Description <code>messages</code> <code>Sequence[str]</code> <p>A list of messages in the conversation.</p> <code>summary</code> <code>Sequence[str]</code> <p>A list of summaries generated during the process.</p> <code>instruction</code> <code>Sequence[str]</code> <p>A list of instructions for the agent.</p> <code>taipi_body</code> <code>Sequence[str]</code> <p>The body of the Taiphi response.</p> <code>user_raw_query</code> <code>Sequence[str]</code> <p>The original, unprocessed user query.</p> <code>user_refined_query</code> <code>Sequence[str]</code> <p>The processed and refined user query.</p> <code>parameters_to_taiphi</code> <code>Sequence[str]</code> <p>Parameters to be passed to Taiphi.</p> Note <p>All attributes are annotated with <code>operator.add</code>, indicating that they can be concatenated or added together when updating the state.</p> Source code in <code>taiphi/statemachine.py</code> <pre><code>class AgentState(TypedDict):\n    \"\"\"\n    Represents the state of the agent throughout its execution.\n\n    This TypedDict defines the structure of the agent's state, including\n    various fields that are updated and accessed during the agent's operation.\n\n    Attributes:\n        messages (Sequence[str]): A list of messages in the conversation.\n        summary (Sequence[str]): A list of summaries generated during the process.\n        instruction (Sequence[str]): A list of instructions for the agent.\n        taipi_body (Sequence[str]): The body of the Taiphi response.\n        user_raw_query (Sequence[str]): The original, unprocessed user query.\n        user_refined_query (Sequence[str]): The processed and refined user query.\n        parameters_to_taiphi (Sequence[str]): Parameters to be passed to Taiphi.\n\n    Note:\n        All attributes are annotated with `operator.add`, indicating that\n        they can be concatenated or added together when updating the state.\n    \"\"\"\n    messages: Annotated[Sequence[str], operator.add]\n    summary: Annotated[Sequence[str], operator.add]\n    instruction: Annotated[Sequence[str], operator.add]\n    taipi_body: Annotated[Sequence[str], operator.add]\n    user_raw_query: Annotated[Sequence[str], operator.add]\n    user_refined_query: Annotated[Sequence[str], operator.add]\n    parameters_to_taiphi: Annotated[Sequence[str], operator.add]\n</code></pre>"}]}